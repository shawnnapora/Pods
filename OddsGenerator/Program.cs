using System;
using Pods;
using Pods.Odds;

namespace OddsGenerator
{
    class Program
    {
        static void Main(string[] args)
        {
            var output = new Output();
            output.AppendLine("/* Generated by OddsGenerator, do not edit */");

            using (new TopMatter(output))
            {
                output.AppendLine($"public static readonly Dictionary<int, {NestedType}> OddsByPlayers = new Dictionary<int, {NestedType}>");
                output.AppendLine("{{");

                var (minPlayers, maxPlayers) = (2,9);
                for (int i = minPlayers; i <= maxPlayers; i++)
                {
                    output.Indent();
                    GenerateOddsTableEntry(output, i);
                    output.Indent(-1);
                
                    output.AppendLine(i < maxPlayers ? "},{" : "}};");
                }
            }

            Console.WriteLine(output);
        }

        private static void GenerateOddsTableEntry(Output output, int players) 
        {
            output.AppendLine($"{players}, new {NestedType}");
            output.AppendLine("{");
            GeneratedOdds(output, players);
            output.AppendLine("}");
        }

        private static void GeneratedOdds(Output output, int players)
        {
            var ranks = Enum.GetValues(typeof(Rank));
            Array.Reverse(ranks);
            
            foreach (Rank rowRank in ranks)
            {
                output.Indent();
                output.Tab();
                foreach (Rank colRank in ranks)
                {
                    // break the line and indent halfway through:
                    if (colRank == Rank.Eight)
                    {
                        output.AppendLine();
                        output.Indent();
                        output.Tab();
                    }

                    string statString;
                    if (rowRank <= colRank)
                    {
                        statString = $"{colRank.Stringify()}{rowRank.Stringify()}o";
                    }
                    else
                    {
                        statString = $"{rowRank.Stringify()}{colRank.Stringify()}s";
                    }
                    
                    var player = Player.FromStatsString(statString);
                    var statsHand = new StatsHoleCards(player);
                    var playerStats = PreflopOdds.RunMany(player, players, 25000);
                    
                    output.Append($@"{{Hand(""{statString}""), {playerStats[statsHand].WinRate:0.00}}}, ");
                }
                
                output.AppendLine();
                output.Indent(-2);
            }
        }

        private class TopMatter : IDisposable
        {
            internal TopMatter(Output output)
            {
                _output = output;
                AddTopMatter(output);
            }
            
            public void Dispose()
            {
                CloseTopMatter(_output);
            }
            
            private static void AddTopMatter(Output output)
            {
                output.AppendLine("using System.Collections.Generic;");
                output.AppendLine();
                output.AppendLine("namespace Pods.Odds");
                output.AppendLine("{");
                output.IndentAppendLine("public static partial class PreflopOdds");
                output.AppendLine("{");
                output.Indent();
            }

            private static void CloseTopMatter(Output output)
            {
                output.DedentAppendLine("}"); // class Odds {}
                output.DedentAppendLine("}"); // namespace Pods {}
                output.AppendLine();
            }

            private readonly Output _output;
        }

        private const string NestedType = "Dictionary<StatsHoleCards, double>";
    }
}